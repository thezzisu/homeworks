# DSA Homework 8

> 我保证没有抄袭他人作业。
张子苏 2100012732

## Q1

算法描述如下：

定义修改的基数排序`SortStr`为在上下文`{S, i}`上的问题，其中S为字符串数组，其中所有字符串的前i位相同。

算法`SortStr`定义如下：
- 按照字符串的第`i + 1`位进行基数排序
- 对`S`分割为`S1, S2, ..., Sk`，其中`Si`的前`i+1`位相同
- 对每个大小大于1的`Si`递归使用`SortStr {Si, i + 1}`

对给定的初始输入S = {s1, ..., sm}， 使用`SortStr {S, 0}`即可完成排序。

对时间复杂度的证明：对S中每个字符串的每一个字符`c`，只会在过程中被使用一次，而这是复杂度最高的操作，因此算法复杂度为`O(Sigma li)`

## Q2

### 1

仅需要维护一个最小堆。对于新元素Ai，将其入堆，若堆大小大于`k`，则将堆顶删除。平均复杂度O(nlogK)，适合流式数据。

### 2

类似快排思想。每次将递归所属数组切片进行分区，分为左右两块，记为`LEFT`和`RIGHT`。

- 若左边的数量大于等于K，则在左侧递归。
- 否则，在右侧递归寻找其前`K - len(LEFT)`大。

均摊意义下，递归深度log(n)，深度为i的递归内部复杂度为O(n/(2^i))，总复杂度O(n)。

## Q3

正确性：

- 块内有序：由插入排序正确性得
- 块间有序：任取二A中元素`A[i]，A[j]`，则其不在同一个桶，由H非严格单增，知`A[i]!=A[j]`且`A[i]，A[j]`之大小关系与桶顺序相同，得证。

最好复杂度：O(n)，当桶内有序时；
最坏复杂度：O(n^2/m)，当插入排序完全进行时；
平均复杂度：O(n^2/m)
