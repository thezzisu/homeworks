# DSA Homework 5

> 我保证没有抄袭他人作业。

张子苏 2100012732

## Q1

不成立。反例：
```
  A     A
 /       \
B         B
```
前序遍历、后序遍历均为`AB`。

## Q2

### 1

```
   5
  / \
 1   7
    / \
   6   8
S1 = {1, 6}
S2 = {5, 7, 8}
S3 = {}
```

反例：取`a=6,b=5`。

### 2

```
    5
   /
  3
 / \
1   4

S1 = {}
S2 = {1, 3, 5}
s3 = {4}
```

反例：取`b=5,c=4`。

### 3

正确。

取`a`到根的路径`Pa`与`S2`的交集中深度最大的节点`pa`，`b`到根的路径`Pb`与`S2`的交集中深度最大的节点`pb`。

已知`a != pa && b != pb && pa != pb`。不失一般性，假设`pa`为`pb`的祖先节点。

则我们有`a < pa < t`，其中`t`是任意属于`pa`的两颗子树中不包含`a`的子树的任意节点。显然`b`是`t`的一个合法取值。证毕。

## Q3

```cpp
bool check_heap(int m, int *a)
{
  for (int i = 1; i <= m; i++)
  {
    int l = i << 1, r = l | 1;
    if (l > m)
      break;
    if (a[l - 1] > a[i - 1])
      return false;
    if (r > m)
      break;
    if (a[r - 1] > a[i - 1])
      return false;
  }
  return true;
}
```

## Q4

首先对给定权重构建优先队列，队首为最小权节点。

计算第一次合并的节点数`init = n % (k - 1) <= 1 ? n % (k - 1) + k - 1 : n % (k - 1)`。首次合并优先队列的前init个节点，并将其根节点入队（根节点权为其所有儿子节点权和）；
然后循环合并队列的前`k`个节点即可。

示例：
```
1,4,9,16,25,36,49,64,81,100
init = 2
1  4
\  /
  5  9 16
  \  | /
    30 25 36   49 64 81
     \  | /    \   |  /
       91         194     100
        \          |       /
                 385
```

## Q5

### 1

证明：

若根节点的距离为k，则任意深度属于`1..(k-1)`的节点均非外界点，也即均有左右儿子。从而该树必包含一颗深度为`k`的满二叉树，则至少有`2^(k+1)-1`个节点。

### 2

证明：

易知根节点距离无法大于`log_2(n + 1) - 1`，否则与1之结论矛盾。由定义知根节点距离最少为0。证毕。
